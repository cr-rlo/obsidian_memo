- 무상태성: 서버가 클라이언트의 이전 요청 상태를 기억하지 않고, 각 요청을 완전히 새로운 것으로 간주하여 처리함
- 애플리캐이션 계층: HTTP,FTP
- 전송 계층: TCP, UDP
- 인터넷 계층: IP
- 네트워크 인터페이스 계층

- 순서
	1. 프로그램이 메세지 생성
	2. socket 라이브러리를 통해 전달
	3. TCP 정보 생성, 메세지 데이터 포함
	4. IP 패킷 생성, TCP 데이터 포함

## 인터넷 네트워크
- IP: 인터넷 프로토콜
- 클라이언트가 ip주소를 부여 받고 메세지를 받는 친구도 ip 필요
- 출발지 ip, 목적지 ip
- ip패킷 전달, 서버 패킷 전달
- ip 프로토콜의 한계
	- 비연결성: 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
	- 비신뢰성: 중간에 패킷이 사라지거나 순서대로 오지 않는 경우
	- 프로그램 구분: 같은 ip를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상일 경우

- TCP: ip 프로토콜의 문제 해결
- 전송제어 프로토콜
- 연결지향 - TCP 3way handshake(가상 연결)
	- 연결을 먼저 가상으로 한 다음 메세지 전달
- 데이터 전달 보증
	- 메세지 누락을 알 수 있음
	- 데이터를 잘 받았는지 응답
- 순서 보장
	- 순서 정보가 들어 있기 때문에 가능
- 신뢰할 수 있는 프로토콜
- 현재 대부분 사용 중

- UDP
- 하얀 도화지에 비유 기능이 거의 없음
- 데이터 전달 보증, 순서 보장 X
- 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름
- ip와 거의 같다, port, 체크섬 정도만 간단하게 추가되어 있음
- 애플리케이션에서 추가 작업 필요
- TCP는 이미 최적화 되어있기 때문에 최적화하고 싶으면 UDP를 수정 가능

## TCP 3way handshake
1. SYN: 접속 요청
2. ACK: 요청 수락 + SYN
3. ACK
4. 데이터 전송

## 포트
- 한 번에 둘 이상 연결에야 한다면 어떤 패킷에서 온 정보인지 구분 어려움
- 포트는 같은 ip 내에서 프로세스 구분
- 0~65535 할당 가능

## DNS
- ip는 변경될 수 있고 기억하기 어렵다는 문제가 있음
- 이를 해결하기 위해 도메인 명 할당

## URI
- uri는 로케이터 이름 또는 둘 다 추가로 분류될 수 있음
- url은 리소스가 이 위치에 있다는 정보, 리소스가 있는 위치를 저장
- urn은 리소스의 이름 정보, 리소스에 이름 부여
- 위치는 변할 수 있지만 이름은 변하지 않는다
- 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화되어 있지 않음
- 
- uniform: 리소스 식별하는 통일된 방식
- resource: 자원, uri로 식별할 수 있는 모든 것(제한 없음)
- identifier: 다른 항목과 구분하는 데 필요한 정보

- query: key=value의 형태, ?로 시작, &로 추가 가능
- 

## 웹 브라우저 요청 흐름
- dns 조회
- ip, port 정보 찾아냄
- http 요청 메세지 생성
- 요청 패킷 전달
- 도착한 요청 패킷에서 http메세지 분석
- http 응답 메세지 도출
- 웹브라우저 렌더링

## HTTP
- hyper text transfer protocol
- html, text, 이미지 등 거의 모든 형태의 데이터 전송 가능
- 서버 간에 데이터를 주고 받을 때도 대부분 http 사용
- 클라이언트 서버 구조
- 무상태 프로토콜, 비연결성
	- 서버가 클라이언트의 상태를 보존 x
	- 서버 확장성 높음, 응답서버를 쉽게 바꿀 수 있음
	- 상태를 유지해야하는 경우가 있어서 모든 것을 무상태로 설계하기엔 한계가 있음
- http 메세지를 통해 통신
- 단순함, 확장 가능
- http 지속 연결

## HTTP 메세지
- < 요청 메세지 >
- 시작라인
	- 종류: GET, POST, PUT, DELETE...
	- 서버가 수행해야 할 동작 지정
- 요청 대상
	- 절대경로로 시작하는 경로


- < 응답 메세지 >
	- http 버전, http 상태코드: 요청 성공, 실패를 나타냄
	- 상태코드 설명 글 이유문구
- http 헤더
	- 필드네임은 대소문자 구분 없음
	- http 전송에 필요한 모든 부가 정보가 들어가 있음
	- 표준헤더가 너무 많아서 필요시 임의의 헤더 추가 가능
- 매새지 바디용도
	- 실제 전송할 데이터, 이미지 영사 ㅇ등등 바이트로 표현할 수 있는 모든 데이터 정보

## HTTP 메서드
- api 설계
- api uri 설계
- 가장 중요한 것은 리소스 식별
- 리소스란 회원이라는 개념 자체가 리소스이다.
- 회원을 등록하고 수정하고 조회하는 것 모두 배제, 회원이라는 리소스만 식별하면 됨
- 회원 리소스를 uri에 베팅
- 리소스 식별, uri 계층 구조 활용
- 계층 구조상 상위 컬렉션으로 보고 복수단어 사용 권장
- http 메서드 종류
	- get: 리소스 조회, 서버에 전달하고 싶은 데이터는 쿼리를 통해서 전달
	- post: 새 리소스 생성(등록), 요청 데이터 처리, 다른 메서드로 처리하기 애매한 경우
	- put: 리소스를 대체, 해당 리소스가 없다면 생성, 클라이언트가 리소스 위치를 알고 uri 지정 
	- patch: 리소스 부분 변경
	- delete: 리소스 삭제

## HTTP 메서드의 속성
- 안전: 호출해도 리소스를 변경하지 않는다. ex) get은 안전함
- 멱등: 한 번 호출하면 두 번 호출하든 100번 호출하든 결과가 똑같음
	- get, put, delete 와 같은 메서드들. post는 두 번 호출하면 같은 결제가 중복해서 발생할 수 있기 때문에 멱등하지 않다.
	- 자동 복구 메커니즘. 서버가 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는 가를 판단하는 근거
- 캐시가능: 응답  결과 리소스를 캐시해서 사용해도 되는가 
	- get, head 정도만 캐시로 사용
	- post, patch는 본문 내용까지 캐시 키로 고려해야하는데, 구현이 쉽지 않음

## 클라이언트에서 서버로 데이터 전송
- 쿼리 파라미터를 통한 데이터 전송
	- get, 정렬 필터를 쓸 때 주로 사용
- 메세지 바디를 통한 데이터 전송
	- post, put patch, 회원가입, 상품 주문, 리소스 등록 변경 에서 주로 사용


- 정적 데이터 조회
- 동적 데이터 조회: 쿼리 파라미터 사용
	- 주로 검색, 정렬 필터, 정렬 조건에 주로 사용
	- 조회는 get 사용, get은 쿼리 파라미터를 사용해서 데이터 전달
- HTML form 데이터 전송
	- post 전송 - 저장
	- form의 내용을 메시지 바디를 통해 전송(key=value, 쿼리 파라미터 형식)
	- 전송 데이터를 url 인코딩 처리
	- get 전송도 가능
	- 웹 브라우저가 생성한 요청 http 메세지
	- multipart/form-data: 파일 업로드 같은 바이너리 데이터 전송 시 사용
		- 다른 종류의 여러 파일과 폼의 내용 함께 전송 가능

## HTTP API 데이터 전송
- 서버 to 서버 
- 앱 클라이언트, 웹 클라이언트
- post, put, patch: 메세지 바디를 통해 데이터 전송
- get: 조회, 쿼리 파라미터로 데이터 전달
- context type: application, json 주로 사용
- 

## HTTP API 설계 예시
- http api 컬렉션: post 기반 등록
	- ex) 회원관리 api 제공
- http api 스토어: put 기반 등록
	- ex) 정적 컨텐츠 관리, 원격 파일 관리
- http form 사용: get, post만 지원. 웹페이지 회원 관리

ex) 회원관리 시스템 설계
- api 설계 - post 기반 등록
	- 회원 목록 -> get
	- 회원 등록 -> post
	- 회원 조회 -> get
	- 회원 수정 -> patch, put, post
	- 회원 삭제 -> delete

## post와 put 회원 등록 차이
- post - 신규 자원 등록 특징
	- 클라이언트는 등록될 리소스의 uri를 모른다
	- 회원등록 /members -> post
	- 서버가 새로 등록된 리소스 uri를 생성해준다
	- 컬렉션: 서버가 관리하는 리소스 디렉토리, 서버가 uri를 생성하고 관리 
	- /members 가 컬렉션
- put 기반 등록
	- 클라이언트가 리소스 uri를 알고 있어야 한다
	- 파일 등록 /files/{filename} -> put
	- 클라이언트가 직접 리소스의 uri를 지정함
	- 스토어: 클라이언트가 관리하는 리소스 저장소
	- 클라이언트가 리소스의 uri를 알고 관리
	- 여기서 스토어는 /files
- html form 사용
	- html form 은 get, post만 사용
	- 이런 제약을 해결하기 위해 동사로 된 리소스 경로 사용
	- post의 /new, /edit, /delete가 컨트롤 uri
	- 컨트롤러, 컨트롤 uri: 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행, 동사를 직접 사용
	- http 메서드로 해결하기 애매한 경우 사용

## HTTP 상태코드
- 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능
- 1xx: 요청이 수신되어 처리중, 거의 사용하지 않음
- 2xx: 요청 정상 처리
	- 200 ok: 요청 성공
	- 201 created: 요청 성공해서 새로운 리소스가 생성됨
	- 202 accepted: 요청이 접수되었으나 처리가 완료되지 않음
	- 204 no content: 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음
- 3xx: 요청을 처리하려면 추가 행동이 필요, 응답 결과에 location 헤더가 있으면 location 위치로 자동 이동
- 리다이렉션 이해
	- 300 multi choices
	- 일시 리다이렉션: 일시적인 변경, 주문완료 후 주문 내역 화면으로 이동
		- 302 found: 리다이렉트 시 요청 메서드가 get으로 변하고 본문이 제거 될 수 있음
		- 307 temporary redirect: 302와 기능은 같음, 리다이렉트 시 요청 메서드와 본문 유지 요청 메서드를 변경하면 안된다
		- 303 see other: 302와 기능은 같음 리다이렉트 시 요청 메서드가 get으로 변경
		- prg: 일시적인 리다이렉션
			- post로 주문후에 새로 고침하며 중복 주문 가능성
			- 이를 막기 위해 get으로 주문 결과 화면을 리다이렉트
			- 새로고침해도 결과 화면을 get으로 조회
			- 중복 주문 대신 결과화면만 get으로 조회
	- 영구 리다이렉션: 특정 리소스의 uri가 영구적으로 이동
		- 301  moved permanently: 리다이렉트 요청 메서드가 get으로 변하고 본문이 제거될 수 있음
		- 308 permanent redirect: 301과 기능은 같음, 리다이렉트 시 요청 메서드와 본문 유지 
	- 특수 리다이렉션: 결과 대신 캐시를 사용
		- 304 not modified: 캐시를 목적으로 사용
		- 클라이언트에게 리소스가 수정되지 않았음을 알려줌
		- 클라이언트는 로컬 pc에 저장된 캐시를 재사용 함(캐시로 리다이렉트)
		- 304 응답은 응답에 메세지 바디를 포함하면 안됨
		- 조건부 요청 get, head시 사용
- 4xx: 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
	- 클라이언트가 이미 잘못된 요청, 데이터를 보내고 있기 때문에, 똑같은 재시도가 실패함
	- 400 bad request: 클라이언트가 잘못된 요청을 보냈기 때문에 요청 내용을 다시 검토하고 보내야 함
	- 401 unauthorized: 인증 되지 않음, 클라이언트가 해당 리소스에 대한 인증이 필요함
	- 403 forbidden: 서버가 요청을 이해했지만 승인을 거부함. 
	- 404 not found: 요청 리소스를 찾을 수 없음. 또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을 때
- 5xx: 서버오류, 서버가 요청을 정상 처리 하지 못 함
	- 서버 문제기 때문에 재시도하면 성공할 수도 있음
	- 500 internal sever error
	- 503 service unavailable: 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음
- 클라이언트가 인식할 수 없는 상태코드를 서버가 반환하면 클라이언트는 상위 상태코드로 해석해서 처리

## HTTP 헤더
- general 헤더: 메세지 전체에 적용되는 정보
- request 헤더: 요청 정보
- response 헤더: 응답 정보
- entitiy 헤더: 엔티티 바디 정보

- HTTP BODY
- 메세지 본문은 엔티티 본문을 전달하는 데 사용
- 엔티티 본문은 요청이나 응답에서 전달할 실제 데이터
- 엔티티 헤더는 엔티티 본문의 데이터를 해석할 수 있는 정보 제공
	- 데이터 유형, 데이터 길이, 압축 정보 등
- 엔티티라는 말이 사라지고 표현이라는 말이 생겨남
- 메시지 본문을 통해 표현 데이터 전달
- 메시지 본문 = 페이로드
- 표현은 요청이나 응답에서 전달할 실제 데이터'
- 표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공
- 표현 헤더는 표현 메타데이터와 페이로드 메시지를 구분해야 함

## 표현
- context-type: 표현 데이터의 형식
- context-encoding: 표현 데이터의 압축 방식
	- 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가
	- 데이터를 읽는 쪽에서 인코딩 헤더 정보로 압축 해제
- context-language: 표현 데이터의 자연 언어
- context-length: 표현 데이터의 길이
- 표현 헤더는 전송, 응답 둘 다 사용

## 협상 content negotiation
- 클라이언트가 선호하는 표현 요청
- accept: 클라이언트가 선호하는 미디어 타입 전달
- accept-charset: 클라이언트가 선호하는 문자 인코딩
- accept-encoding: 클라이언트가 선호하는 압축 인코딩
- accept-language: 클라이언트가 선호하는 자연언어
- 협상 헤더는 요청시에만 사용

- 협상과 우선순위
	- quality values(q)값 사용
	- 0~1. 클수록 높은 우선 순위
	- 생략하면 1
	- ex) ko-KR, ko;q=0.9, en;q=0.8 ...
- 구체적인 것이 우선한다
	- 구체적인 것을 기준으로 미디어 타입을 맞춘다
	- 

## 전송 방식
- 단순전송
- 압축전송: content-encoding 추가로 넣어줘야 함
- 분할 전송: transfer-encoding. context-length를 넣으면 안됨. 알 수 없기 때문
- 범위 전송

## 일반 정보 - 단순한 헤더
- from: 유저 에이전트의 이메일 정보
	- 검색 엔진 같은 곳에서, 주로 요청에서 사용
- referer: 이전 웹페이지 주소
	- 현재 요청된 페이지의 이전 웹페이지 주소
	- 유입 경로 분석 가능
	- 요청에서 사용
- user-agent: 유저 에이전트 애플리케이션 정보
	- 클라이언트의 애플리케이션 정보
	- 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능
	- 요청에서 사용
- server: 요청을 처리하는 오리진 서버의 소프트웨어 정보
	- 응답에서 사용
- date: 메세지가 생성된 날짜

## 특별한 정보 - 복잡한 헤더?
- host: 요청한 호스트 정보(도메인)
	- 요청에서 사용
	- 필수 !!!!!!
	- 하나의 서버가 여러 도메인을 처리해야 할 때 
	- 하나의 ip 주소에 여러 도메인이 적용되어 있을 때
- location: 페이지 리 다이렉션
	- 웹 브라우저는 3xx 응답 결과에 location 헤더가 있ㅇ면 location 위치로 자동 이동
- allow: 허용 가능한 HTTP 메서드
	- 405에서 응답에 포함해야 함
	- allow: get, head, put
- Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간

## 쿠키
- set-cookie: 서버에서 클라이언트로 쿠키 전달(응답)
- cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청 시 서버로 전달

- http는 기본적으로 무상태 프로토콜
- 클라이언트와 서버가 요청과 응답을 주고 받으면 연결이 끊어짐
- 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못 함
- 클라이언트와 서버는 서로 상태를 유지하지 않음

- 모든 요청과 링크에 사용자 정보를 포함하는 대안이 있기는 하지만 좋은 대안이 아님

- 이를 해결하기 위한 쿠키
- 로그인 시 입력한 회원 정보를 서버가 set-cookie 헤더
- 회원 정보를 쿠키 저장소에 저장
- 모든 요청에 쿠키 정보 자동 포함

- 사용처: 사용자 로그인 세션 관리, 광고 정보 트래킹
- 쿠키 정보는 항상 서버에 전송됨
	- 네트워크 트래픽 추가 유발
	- 최소한의 정보만 사용
	- 서버에 전송하지 않고, 웹브라우저 내부에 데이터를 전송하고 싶으면 웹 스토리지 참고
	- 보안에 민감한 데이터는 저장하면 안됨
	- 

- 쿠키의 생명주기
	- set-cookie: expires=날짜
		- 만료일이 되면 쿠키 삭제
	- set cookie: max-age=3600 (3600초)
		- 0이나 음수를 지정하면 쿠키 삭제
- 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지
- 영속 쿠키: 만료날짜를 입력하면 해당 날짜가지 유지

- 쿠키 - 도메인
- domain=example.com
- 명시: 명시한 문서 기준 도메인 + 서브 도메인 포함
- 생략: 현재 문서 기준 도메인만 적용

- 쿠키 - 경로
- 이 경로를 포함한 하위 경로 페이지만 쿠키 접근
- 일반적으로 path=/ 루트로 지정

- 쿠키 - 보안
- secure: 쿠키는 http, https를 구분하지 않고 전송, secure을 적용하면 https인 경우에만 전송
- httpOnly: xss 공격 방지, 자바스크립트에서 접근 불가, http 전송에만 사용
- sameSite: XSRF 공격 방지, 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송
- 

## 캐시
- 캐시 적용
	- 첫 번째 요청: 응답 결과를 캐시에 저장
	- 두 번째 요청 시 캐시에서 내려받아 사용 
- 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 됨
- 비싼 네트워크 사용을 줄일 수 있음
- 브라우저 로딩 속도가 매우 빨라짐
- 캐시 시간 초과. 다시 요청. 다시 캐시에 저장
	- 캐시 유효 시간이 초과되면 서버를 통해 데이터를 다시 조회하고 캐시를 갱신함
	- 이때 다시 네트워크 다운로드가 발생함. 이를 해결하기 위한 방법

- 캐시 시간 초과
- 캐시 유효 시간이 초과해서 서버에 다시 요청하면 
- 서버에서 기존 데이터를 변경하거나 변경하지 않는 두가지 상황 

- 캐시 만료 후에도 서버에서 데이터를 변경하지 않음
- 데이터를 전송하는 대신에 저장해두었던 캐시를 재사용할 수 있음
- 단, 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법 필요
-> 검증 헤더 추가
- 첫 번째 요청 시 데이터가 마지막에 수정된 시간 추가 가능
- 응답 결과 저장, 유효시간, 데이터 최종 수정일 저장(검증 헤더)
- 두번 째 요청시 캐시 시간 초과
- 캐시가 가지고 있는 데이터 최종 수정일과 서버가 가진 데이터와 비교(조건부 요청)
- http 바디가 없는 헤더만 있는 응답 전송
- 응답 결과 재사용

- 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면
- 304 not modified + 헤더 메타 정보만 응답(바디x)
- 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신
- 클라이언트는 캐시에 저장되어있는 데이터 재활용
- 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드

- 검증헤더: 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
	- last-modified, ETag
- 조건부 요청 헤더
	- 검증 헤더로 조건에 따른 분기
	- If-modified-Since: Last-Modified 사용
		- 이후에 데이터가 변경되면: 200, 모든 데이터 전송(body 포함)
		- 이후에 데이터가 변경되지 않았으면 304, 헤더 데이터만 전송
	- If-None-Match: ETag 사용
		- 태그가 다르면 200 OK
		- 태그가 같으면 304 not modified

## 캐시와 조건부 요청 헤더
- 캐시 제어 헤더
	- cache-control: max-age
		- 캐시 유효시간, 초 단위
	- cache-control: no-cache
		- 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용
	- cache-control: no-store
		- 데이터에 민감한 정보가 있으므로 저장하면 안됨
		- 메모리에서 사용하고 최대한 빨리 삭제
		- 
	- expires: 캐시 만료일 지정
		- 정확한 날짜로 지정.
		- 더 유연한 cache-control: max-age 사용 권장
		- cache-control: max-age와 함께 사용하면 expires는 무시
	- cache-control: public
		- 응답이 public 캐시에 저장되어도 됨
	- cache-control: private
		- 응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함
		- 예를 들어 프록시 캐시는 public이라 프록시에 저장되면 안됨
	- cache-control: s-maxage
		- 프록시 캐시에만 적용되는 max-age
	- age:60
		- 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)

## 프록시 캐시
- 예를 들어 한국에 있는 클라이언트가 미국에 있는 원서버에 접근하기에는 시간이 걸림
- 한국 어딘가에 프록시 캐시 서버에 접근. 시간 훨씬 단축

## 캐시 무효화
- cache-control: no-cache, no-store, must-revalidate
- pragma: no-cache
- 확실한 캐시 무효화 응답
- must-revalidate:원서버에 접근할 수 없는 경우, 항상 오류가 발생해야함
	- 504 gateway timeout
	- 캐시 만료 후 최초 조회시 원 서버에 검증 해야함




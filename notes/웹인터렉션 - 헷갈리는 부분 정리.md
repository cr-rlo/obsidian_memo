## CSS 작성 시
- css는 글자 기반 언어
- 즉. 글자로 명령을 구성해야 함
- ex) transform: rotateX(20deg) rotateY(10deg);
- 위 문장은 문자 타입임. 전체가 글자 문자열 -> 컴퓨터 입장에서는 그냥 글자 덩어리
- 컴퓨터는 rotateX(20deg) rotateY(10deg) 글자 덩어리 전체를 하나의 지시문으로 읽음. 개념을 따로 따로 이해하는 것이 아님
- js에서 transform 값을 바꾸고 싶다면 글자 형태 그대로 만들어서 넣어줘야 함
- js는 문자열을 반드시 ""로 감싸야 하기 때문에 css 값을 바꾸기 위해 "" 사용

## CSS
- .character[data-direction='forward'] {
  transform: rotateY(180deg);}
- .character로 클래스 이름이 character인 요소 잡아냄
- [[data-direction='forward']] data-direction이 forward인 경우에만 적용
- css 에서 대괄호는 속성 선택자. html 요소의 속성을 검사해서 조건에 맞는 요소 고르기

- character.dataset.direction = "forward";
	- html의 요소의 data-direction 속성값을 js에서 forward로 바꾼다는 의미
	- 즉 js가 html에 속성 값을 써주는 효과
	- html 속성 data-direction은 하이픈(-)을 쓰지만 js에서는 하이픈이 변수이름에 들어갈 수 없음
	- 따라서 js 가 자동으로 data-를 dataset.으로 변환
	- 

## HTML 속성
- html 속성이란 class,, id, data-direction 등과 같이 태그 하나하나에 정보를 붙여주는 것
- data로 시작하는 속성은 개발자가 마음대로 정보를 태그에 붙일 수 있는 자유로운 속성
	- 개발자 마음대로 이름 붙이고 값도 아무거나 넣을 수 있는 데이터 저장소 같은 느낌
	- 직관적으로 말하자면 메모지 같은 것
	- direction이라는 이름의 정보가 forward이다”라는 메모를 붙인 것.
	- 저장하는 값은 오직 문자열, 값에 특정한 의미가 있는 것은 아님. 개발자가 어떻게 쓸지 자유롭게 결정
- js 입장에서 html에 붙여둔 데이터를 읽을 방법이 필요한데 그게 바로 dataset
	- dataset은 그냥 data- 속성을 js에서 읽고 쓰기 위한 객체

## js와 html, css 의 관계
- html은 초기 상태만 표현할 수 있음
	- 즉 페이지가 로드될 때 처음부터 코딩된 상태로, 바뀌지 않는 정적인 상태로 표현됨
	- 하지만 상황에 따라 방향이나 상태가 바뀌어야 하는 경우가 생김
	- 이때, html은 정적 구조이기 때문에 js가 바꿔주기 전에는 스스로 변할 수 없음
- js는 움직임이나 이벤트를 감지할 수 있음
	- 예를 들어 addEventListner를 사용하면 기보드 입력이나 클릭 등, 이벤트를 감지하여 html 속성을 변경하고 css가 그에 맞는 스타일을 적용시키는 것임
	- js는 상태를 업데이트 하는 역할을 수행하고 css는 그렇게 바뀐 상태에 따라 화면 표현을 바꾸는 역할을 수행하는 것임

## js 작성 시 백틱을 쓰는 경우
- ex) `rotateX(${mousePos.y * 5}deg) rotateY(${mousePos.x * 5}deg)`
- 일단 초기 js는 문자열과 변수를 합칠 때 +로 연결해야 했음
	- transform 값 자체가 문자열이므로, 변수와 문자열을 이어붙여 최종 transform 문자열을 완성해야 하기 때문
	- "rotateX(" + (mousePos.y * 5) + "deg) rotateY(" + (mousePos.x * 5) + "deg)"
	- 글자 "rotateX(" , 숫자, 글자 "deg)" 를 붙여서 하나의 글자를 만드는 것
- 백틱을 쓰면 문자열을 합칠 필요가 없음
	- 백틱이 알아서 문자열을 자동으로 조립해 주기 때문에 ${ }안에 변수나 계산식만 넣으면 됨
## JS 객체를 만드는 틀 - 생성자 함수
- function Character() {
  this.mainElem = document.createElement('div'); 
}
- 비슷한 구조의 객체를 여러 개 만들 때 한 번에 만드는 방식
- 즉, 규칙을 만들어 두는 것
- 객체를 만드는 이름은 아무거나 해도 됨. 그러나 일반적으로 생성자 함수는 대문자로 시작
- new를 붙여 함수를 호출 한다면 js가 객체를 만드는 틀로 쓰겠다는 것을 인식함
- 예시에서 this를 사용한 것은 객체에 속성을 넣겠다는 의미
	- 즉, 지금 생성중인 객체에 이러한 속성을 넣어라 라는 의미
- 예시에서 속성 값으로 document.createElement('div'); 를 넣은 것은 객체가 사용할 div 요소를 직접 생성하겠다는 의미
- 즉, Character 객체 안에 this.mainElem 이라는 속성을 만들어서 이 캐릭터가 화면에서 쓰는 Dom 요소(div)를 미리 html에 써두는 것이 아니라 생성자 안에 직접 만드는 것
- this.mainElem.classList.add('character'); 이렇게 하면 위에 생성한 div의 class 속성을 < div class="character"> </div >

## JS prototype
- Character.prototype = { constructor: Character, 
  init: function() { ... },
- 자바 스크립트의 함수는 객체 생성자로 자주 쓰임
- 그 함수가 만드는 모든 인스턴스(객체)가 공유하는 메서드는 prototype에 넣어 관리하는 것이 메모리와 성능 측면에서 유리함
- Character.prototype.run = function () {}; 이런식으로 따로따로 넣을 수 있는데
- 예시와 같이 한 줄로 묶어서 { 객체 리터럴 } 안에 한 번에 넣는 방식도 있음
- 다만, 이렇게 새로운 객체로 prototype을 통째로 덮어쓰면, 원래 자동으로 있던 constructor 참조가 바뀌기 때문에 constructor: Character를 넣어 원래 생성자를 가리키게 복원 하는 관례가 생김
- init은 초기 설정 함수
- this는 상황에 따라 가리키는 대상이 바뀌기 때문에 const self = this로 지금의 캐릭터 객체를 self라는 이름으로 저장해 두는 것
	- 따라서 이후 어떤 콜백 안에서도 항상 캐릭터 객체를 가리키도록 만들 수 있음
	- 

## 효율적 운영
- window.addEventListener('scroll', function () {

clearTimeout(self.scrollState);

  
if (!self.scrollState) {

self.mainElem.classList.add('running');

}


self.scrollState = setTimeout(function () {

self.scrollState = false;


self.mainElem.classList.remove('running');

}, 500);


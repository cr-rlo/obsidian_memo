## 블랙박스
- 입력이 있을 때 출력이 있다는 것을 알고 있는 것
- 원리는 알고 있지 않은 상태

## 프로토콜
- '약속'
- 발신자와 수신자 사이 어떻게 소통할 지 정의 해 둔 것
- tcp/ip: 5개의 계층으로 나뉨, 네트워크를 위한 표준 프로토콜 
	- 물리 계층: 데이터링크 계층으로부터 받은 프레임을 물리신호로 전송
	- 데이터 링크 계층: 네트워크 계층에서 받은 패킷에 데이터링크 계층의 약속을 나타내는 헤더와 트레일러를 덧붙임 = 프레임
	- 네트워크 계층: 트랜스포트 계층에서 받은 세그먼트를 데이터로 취급함 + 네트워크 계층의 헤더를 덧붙임 = 패킷
	- 트랜스포트 계층: 애플리케이션 계층에서 받은 데이터에 트랜스포트 계층의 약속을 나타내는 데이터를 맨 앞에 덧붙임(헤더) = 세그먼트
	- 애플리케이션 계층: HTTP 메시지, 애플리케이션 계층의 데이터 전송
- osi 7계층: 국제 표준 프로토콜 그러나 tcp/ip가 더 널리 쓰이고 있음

## 서버와 클라이언트
- 서비스를 제공하는 서버와 서비스를 요청하는 클라이언트
- 파일 서버
- 웹 서버
- 클라이언트의 요청이 많을 수록 서버의 성능이 중요

## 네트워크 토폴로지 - 네트워크의 연결 방식
- 버스 토폴로지
	- 컴퓨터, 라우터 등을 말함
	- 새로운 노드의 추가, 제거가 간단함, 특정 노드에 장애가 발생하더라도 다른 노드에 영향x
	- 중앙 통신 회선을 공유하기 때문에 트래픽이 증가하면 충돌이 발생, 성능이 떨어질 수 있음
- 스타 토폴로지
	- 중앙 노드를 중심으로 다른 노드가 연결
	- 문제가 생겼을 때 발견하기 쉽고 관리 쉬움
	- 주 노드에 문제가 발생하면 전체 네트워크 다운
	- 하나의 노드가 작동하지 않으면 해당 노드가 문제 
- 링 토폴로지
	- 좌우 인접한 노드와 연결되어 원형을 이루는 형태
	- 하나의 노드에서 다른 하나로만 데이터 전송, 충돌 위험 적음
	- 하나의 노드에 문제발생 다른 노드에도 영향
	- 노드의 변경 추가 등이 어려움
- 트리 토폴로지
	- 하나의 노드에 여러 노드가 트리 자료구조 형태
	- 노드의 제거와 추가가 용이하고 자식 부모 구조를 이루고 있어서 장애 해결 쉬움
	- 루트 노드에 문제가 생기면 전체 노드의 다운 가능성
	- 특정 노드에 트래픽이 집중되면 속도 저하
- 매쉬 토폴로지
	- 모든 노드가 직접 연결되는 형태
	- 특정 노드에 문제가 발생하더라도 전체 노드에 영향 없음
	- 모든 노드를 연결해야 하므로 케이블이 많이 필요함, 비용 문제
	- 빠르고 안정적임
## 유니캐스트 브로드캐스트 멀티캐스트 애니캐스트 - 네트워크의 통신 방식
1. 유니캐스트
	- 노드끼리 1:1 통신
	- 노드들은 각자 고유한 주소
	- 출발지 노드가 목적지 노드의 주소를 적어서 연결된 모든 노드로 데이터 전송
	- 각 노드는 전달받은 주소와 자신의 주소 비교
	- 데이터를 전달 받은 노드가 자신의 주소와 일치하면 데이터 처리 다르면 버림
	- 주소 확인 작업은 랜카드가 하므로 cpu에 부담을 주지 않음
	- 데이터를 전송할 노드가 많아진다면 출발지에서 데이터를 여러번 보내야 하고 모든 노드의 트래픽이 증가하는 문제
	
2. 브로드 캐스트
	- 출발지에서 연결된 모든 노드에게 데이터 전송
	- 모든 노드는 데이터를 수신하고 랜카드가 인터럽트를 발생시켜 cpu에서 데이터 처리할 지 말 지 결정
	- 일단 데이터를 받고 그 후에 처리할지 말지 결정 따라서 cpu에 부화를 줌
	- 
3. 멀티캐스트
	- 1:n으로 데이터 전송
	- 일부 그룹에만 데이터를 전송하려할 때 단점이 발생하는 유니캐스트와 브로드 캐스트
	- 데이터를 받고자 하는 그룹을 만들어 그들에게만 전송
	- 유니캐스트 처럼 데이터를 여러번 보낼 필요도 없고 브로드캐스트처럼 억울하게 cpu를 낭비하는 일도 없음
4. 애니캐스트
	- 가장 가까운 노드에만 데이터 전송
	- 브로드캐스트의 문제점을 해결하려고 등장

## 단방향, 반이중, 전이중 통신 - 전송 방식에 따른 통신의 종류
- 단방향 통신
	- 한 방향으로만 데이터 전송
	- 송신측에서만 수신측으로 보낼 수 있음
	- tv나 라디오
	- 송신측이 수신측으로 어떠한 데이터도 받지 않기 때문에 수신측에서 문제가 발생해도 송신측은 알 수 없음
- 반이중 통신
	- 송신을 하는 동안엔 수신을 할 수 없고 수신을 하는 동안엔 송신 불가
	- 무전기
	- 한 노드에서 데이터 전송을하고 종료하는 신호를 보내면 다른 쪽에서 데이터 전송가능
- 전이중 통신
	- 송신과 수신을 동시에 하는 통신
	- 전화기
	- 

## 물리 계층
- 미국으로 데이터를 보낸다는 것은 물리적인 무언가를 미국으로 보낸다는 의미
- 물리적인 무언가는 전기신호, 전자기파 등
- 전기신호는 케이블을 통해 보냄
- 전자기파는 전파보다 넓은 스펙트럼, 유선통신과 무선통신
- 물리적인 신호를 아날로그 신호라고 부름
- 전자기기가 처리하기 위해서는 아날로그 신호를 디지털 신호로 바꿔줘야 함
- 물리계층은 디지털 신호를 아날로그 신호로 바꾸고 목적지 까지 아날로그 신호를 전달
- 목적지에서는 받은 아날로그 신호를 다시 디지털 신호로 바꾸는 처리를 함


## 데이터링크 계층
- 같은 네트워크에서 목적지를 구분하는 계층
- mac주소를 이용해 연결된 컴퓨터를 구분하고 정확히 전송
- 기기에 mac 주소를 부여해 원하는 기기만 데이터를 전달할 수 있도록 함


## 케이블
- 2대 이상의 컴퓨터가 서로 통신하려면 서로 연결하는 케이블이나 전파가 있어야 함
- 물리적으로 데이터를 전송하는 매체라 물리 계층에 해당
- 크게 세가지로 나뉨 
- utp 케이블
	- 흔히 랜선이라고 부름
	- 데스크톱이나 노트북에 유선 인터넷을 연결하는 경우 대부분 이를 사용
	- 전이중 통신이 가능한 통신 케이블
- 동축 케이블
	- 중앙에 데이터를 전송하는 구리 선을 감싼 케이블
	- 자기장 간섭이 적어 utp 케이블 보다 더 멀리 전송할 수 있음
	- 선이 하나기 때문에 반이중 통신만 가능
	- tv나 안테나 선에 사용
- 광 케이블
	- 유리나 플라스틱으로 만들어진 케이블로 빛을 사용
	- 빛을 사용하기 때문에 외부 간섭이 없어 전기를 이용하는 것보다 더 많이, 빠르게 전송 가능
	- 전기는 데이터를 빨리 보내면 왜곡이 생기므로 전송속도의 한계가 있기 때문
	- 빛 신호를 전기로, 전기를 빛 신호로 바꾸는 트랜시버가 필요함


## 랜카드
- 데이터 링크 계층에 해당하는 장치
- 컴퓨터 매인보드에 내장되어 있거나 추가 슬롯에 연결하여 사용
- 애플리케이션 계층부터 시작하여 각 계층을 타고 내려온 최종 디지털 데이터인 프레임을 아날로그 데이터로 바꾸기도 하고 전달받은 아날로그 신호를 데이터 신호로 바꾸기도 함
- 랜카드는 고유의 주소인 mac 주소를 가지고 있음
- 아날로그 데이터가 랜카드에 전달되면 랜카드는 아날로그 데이터를 디지털 데이터로 변환
- 디지털 데이터에서 데이터 링크 헤더에 적힌 목적지 mac주소가 자신의 mac 주소와 일치하는지 비교함
- 일치하면 cpu에 데이터가 왔음을 알리고 일치하지 않으면 버림
- 클라이언트가 요청한 처리를 하고 다시 보내줌
- 아날로그 신호 - 디지털 신호

## mac 주소
- 데이터 링크 계층에서 사용되는 기술
- 각각의 기기를 구분하기 위한 용도로 제조사에서 고유한 주소 부여
- 6비트 8개로 구성 총 48비트
- 앞 24비트는 제조사를 구분할 수 있도록 제조사 코드

## 리피터
- 거리가 멀어서 통신의 장애가 생기는 문제를 해결하기 위한 대안
- 신호를 복원하고 증폭해주는 역할을 하는 장치
- 물리계층

## 허브
- 여러 대의 컴퓨터를 연결하는 중심이 되는 장치
- 컴퓨터는 서로 통신하기 위해서 직접 케이블로 연결하는 것이 아니라 중간에 있는 허브에 케이블로 연결
- 랜선을 꽂을 수 있는 포트 존재
- pc1이 pc4에게 데이터를 전송하고 싶다면 목적지 mac주소를 pc4로 설정하고 연결된 허브로 데이터를 보냄
- 데이터를 수신한 허브는 수신한 포트를 제외한 나머지 포트로 데이터를 전송함
- 즉 브로드 캐스트 함
- 이 과정에서 약해진 신호를 증폭도 함
- 즉, 리피터 역할도 함
- mac 주소에 상관없이 단순히 물리 신호를 브로드캐스팅 하므로 물리계층
- 

## 이더넷과 이더넷 헤더
- 데이터링크 계층
- 데이터 링크 계층에서 가장 많이 사용하는 프로토콜은 이더넷
- 초기에는 동축 케이블을 이용한 버스형 네트워크
	- 여러 대의 컴퓨터를 연결하기 위해 버스형으로 연결
	- BNC T 커넥터에 동축 케이블들을 연결하여 사용했음
	- 그러나 두 대 이상의 컴퓨터가 동시에 신호를 보내면 충돌이 발생
- csma/cd: 충돌을 막기 위해 탄생, 한 순간에 하나의 사용자만 전송
	- 전이중 통신의 발달로 잘 사용하지 않게 됨
- utp케이블과 광케이블의 등장
- 이더넷 헤더와 트레일러가 붙은 전체의 데이터를 프레임이라고 함

## CSMA/CD
- 허브를 통해서 여러 대의 컴퓨터가 통신할 수 있음
- utp 케이블을 허브에 연결하면 스타형 구조
- 그러나 초기에는 동축 케이블을 이용, 발생하는 충돌을 해결하기 위해 탄생
- 동축 케이블에 데이터가 전송되지 않는 것을 확인
- 그러나 여러 pc가 동시에 데이터가 전송되지 않는 것을 확인한 후 데이터를 전송하면 다시 충돌 발생 가능성
- 이때 cd로 충돌을 감지한 컴퓨터는 데이터 전송을 중지하고 모든 컴퓨터에게 충돌이 발생했다는 신호 전송
- 데이터를 전송하고자 하는 컴퓨터는 랜덤한 시간동안 기다렸다가 재전송
- 현재는 전이중 통신을 사용하게 되면서 CSMA/CD는 사용하지 않음

## 브리지
- 동축 케이블을 이용해 버스 토폴로지로 통신하면 CSMA/CD 방식으로 반이중통신만 가능하다는 단점
- UTP 케이블과 허브를 이용해 스타 토폴로지를 구성해도 허브에서 충돌이 발생할 수 있다는 단점
- pc1과 pc2에서 데이터가 허브로 동시에 들어왔을 때 pc1의 데이터는 바로 보내고 pc2의 데이터는 메모리에 보관했다가 하나 처리 후 보내는 방법 -> 기존 허브에 메모리(ram)과 프로세서(cpu)의 역할이 필요해짐
- 이렇게 탄생한 것이 브리지
- 허브에 메모리와 cpu를 결합 -> 전이중 통신 가능
	- mac 주소를 이용해 해당 포트로만 전송할 수 있기 때문에 브로드캐스팅 방식을 사용하지 않아도 되고 콜리젼 도메인이 나눠질 수 있음

## 스위치
- 브리지와 기능적인 차이는 없음
- 단지 성능이 좋아 진 것
- 스위칭 허브라고도 불림
- 브리지, 스위치, 스위칭 허브는 다 똑같은 말
- 데이터 링크 계층
- 통신이 처음 일어나면 스위치의 mac 주소 테이블은 비어 있기 때문에 어느 포트에 어떤 mac 주소가 있는지 모름
- 가장 먼저 스위치는 허브에 전달된 데이터에서 출발지 mac 주소를 보고 mac주소와 포트를 mac 주소 테이블에 저장함
- 스위치는 데이터를 브로드 캐스팅하고(flooding) 자신의 주소인 pc가 데이터 처리
- 스위치끼리 연결되어 트래픽이 커진 브로드캐스트 도메인은 많은 트래픽이 발생하기 때문에 브로드 캐스트 도메인을 나눠줘야 함(라우터) -> 상관없는 영역에서 일어나는 통신 메세지가 나에게 전달되지 않아 쓸데 없는 트래픽이 오지 않음
- 하지만 lan 영역이 나눠지게 되면 기존의 출발지, 목적지 mac 주소만으로는 다른 lan 영역에 있는 컴퓨터에 전송하기 힘듦

## 네트워크 계층
- 데이터를 전송하기 위해서 출발지 ip주소엔 전송하는 사람의 ip주소, 목적지 ip주소엔 전달받을 사람의 ip주소를 적음
- 출발지 mac주소엔 전송하는 사람의 mac주소, 목적지 mac주소에는 전달 받은 사람의 mac주소가 아니라 라우터의 mac 주소를 적고 전송
- 스위치를 통해 라우터로 전달
- 라우터는 목적지의 mac주소를 보고 자신에게 온 데이터 임을 확인하고 이를 처리하면서 목적지 ip 주소를 확인함
- 받은 메세지에서 출발지 mac주소는 라우터의 mac주소, 목적지 mac 주소는 전달받을 사람의 mac 주소를 적고 스위치로 전송함
- 마지막으로 스위치는 해당 데이터를 전달받을 사람에게 전송함
- 네트워크 계층은 다른 Lan 영역을 연결하기 위해 논리적인 주소인 ip 주소를 만들어 라우터라는 장치를 이용하는 게층임
- 라우터를 넘어가지 않는 영역을 lan 영역, 라우터를 넘어가는 영역을 wan(인터넷) 영역이라고 부름

## ip주소
- 허브와 스위치로 연결되어 하나의 브로드캐스트 도메인에 있는 네트워크에서는 mac 주소로만 통신할 수 있었음
- 물리적 주소인 mac 주소 외에 논리적인 주소를 추가로 만들면 lan영역이 나눠져 다른 영역에 있는 컴퓨터에 전송할 수 없는 문제를 해결할 수 있음
- 너무 많은 브로드캐스트로 트래픽이 증가하는 것을 해결하기 위해 브로드캐스트 도메인을 나누면서 논리적인 주소가 필요하게 되었고 그렇게 등장
- ip 주소 덕분에 다른 네트워크에 있는 컴퓨터를 정확하게 나타낼 수 있고 라우터가 복잡한 네트워크에서 경로를 지정해 줌
- 각 pc에 mac 주소와 ip 주소가 할당됨
- 라우터는 여러 개의 포트가 있으므로 포트마다 mac주소와 ip주소가 할당됨

- ip 주소는 모든 호스트와 라우터에 할당됨, 허브와 스위치에는 할당할 필요 없음
- ip주소는 누군가의 집 즉 고유한 주소
- mac주소는 구체적인 주소라고 생각
- ip주소는 그대로 두고 mac주소를 수정하며 이동
- 라우터와 개인정보가 저장되어 있는 라우팅 테이블
- 8비트 4개로 32비트로 구성

## ip클래스와 서브넷 마스크
- ip주소를 효율적으로 관리하기 위한 ip클래스
- 맨 앞 8비트를 네트워크 주소, 나머지 24비트를 호스트 주소로 사용
- 클래스 a~d
- ip주소의 낭비를 막기위해 고안된 서브넷 마스크
- private ip(중복될수도)/ public ip

## ip 헤더(패킷)
- 애플리케이션 계층의 데이터는 트렌스포트 계층으로 전달
- 트랜스포트 계층에서는 받은 데이터에 헤더를 붙임 
	- 이때 UDP 헤더를 붙이면 데이터그램
	- TCP 헤더를 붙이면 세그먼트
- 데이터그램은 다시 네트워크 계층으로 전달됨
- 네트워크 계층에서는 받은 데이터그램에 ip헤더를 붙임 = 패킷
- 패킷은 다시 데이터링크 계층으로 전달되고 이더넷헤더가 붙음 = 프레임
- 프레임은 물리 계층으로 전달되 전기신호로 바뀌어 케이블을 타고 전송됨


## 라우터(공유기)
- 브로드캐스트 도메인을 나누기 위한 라우터
- 네트워크 계층 장비
- LAN 영역을 넘어 통신하기 위하여 라우터로 연결
- 라우터를 넘어간 다른 영역 WAN 영역
- 최대한 빠른 경로 적절히 탐색
	- 라우팅 프로토콜 이용
- 라우터는 목적지 IP를 보고 경로 설정
- 실제로 데이터를 전달할 때는 다음 홉 라우터 또는 목적지 장치의 MAC 주소를 사용
- IP는 최종 목적지를 나타내므로 변하지 않음

## 라우팅 프로토콜 
- 라우팅 테이블은 어떤 네트워크에서 어떤 네트워크로 이동할 때 해당 라우터에서 어떤 인터페이스(포트)로 이동해야하는지가 적혀있는 표
- 여러 알고리즘을 이용해 라우터 간 최적의 경로를 계산함
- 라우팅 테이블을 만드는 두가지 방법: 스태틱 라우팅/다이내믹 라우팅
	- 스태틱 라우팅: 사람이 일일이 주소와 인터페이스 지정
	- 다이내믹 라우팅: 라우터가 다른 라우터와 정보를 주고받아 테이블을 스스로 만듦
- 디폴트 라우터: 목적지를 모르는 경우 디폴트 라우터로 보내 문제 해결
- 루프백 주소: 로컬 호스트 

## 스태틱 라우팅
- 관리자가 라우터에 직접 목적지 네트워크 정보를 입력하는 방법
-  장점: 사람이 직접 설정해주기 때문에 라우터의 cpu가 계산할 것이 많지 않아 처리 속도가 빠르고 메모리도 적게 사용하므로 라우터에 부담이 적음, 보안도 좋음
- 단점: 특정 라우터가 고장나면 전체 네트워크가 마비될 수 있음, 대규모 네트워크에서 설정하기 힘듦

## 다이내믹 라우팅
- interior routing protocol
	- distance vector: RIP 라우터의 부담이 적어 대부분의 라우터에서 지원, coverage time이 큼
	- link state: OSFP coverage time이 적음, 비용이 비싸고 복잡함
- exterior routing ptotocol
	- path vector: BGP
-  자율 시스템(AS) 내에서는 RIP나 OSPF 같은 Interior Protocol을, 사로 다른 AS 간에는 BGP와 같은 Exterior Protocol을 사용
- OSPF는 링크 상태 정보를 네트워크 내 모든 라우터에 전파하고, 각 라우터는 이 정보를 바탕으로 최단 경로를 계산
	-> 이는 RIP의 거리 벡터 방식과 구별

## RIP
- 자율 시스템(as) 내에서 사용되는 동적 라우팅 프로토콜인 distance vector 방식의 rip
- 목적지 라우터까지의 거리(홉)와 목적지까지 가기 위해서 어떤 인접 라우터 방향으로 가는지 벡터(방향)과 거리를 라우팅 테이블에 저장함
- 이 정보를 인접 라우터와 30초마다 공유하는 방식으로 라우팅 테이블 유지
- 30초마다 인접 라우터와 정보를 교환하므로 트래픽이 많이 발생

## OSPF
- 자율 시스템(as) 내에서 사용되는 동적 라우팅 프로토콜인 link state 방식의 ospf
- 각각의 라우터들은 자신과 연결된 모든 이웃 라우터에 lsa(자신의 링크 정보 즉 연결정보)를 전달
- 모든 라우터는 동시다발적으로 각자의 lsa를 연결된 모든 라우터에 전달
- 전달된 lsa는 각 라우터의 link state data base에 저장됨
- 이 lsdb를 통해서 최단 경로 계산
- rip와는 다르게 한 라우터에서 변화가 생기면 다른 모든 라우터에 업데이트되는 시간이 짧음
- 이웃 라우터와 라우팅 테이블을 자주 교환하는 rip와 다르게 링크 정보를 자주 교환하지 않아서 트래픽을 줄일 수 있음
- 홉의 제한이 있지 않아서 대규모 네트워크에서 사용 가능함
- 라우터가 모든 라우팅 정보를 저장하기 때문에 많은 메모리가 필요하고 최단 경로도 계산해야 하므로 cpu도 더 바빠짐
- 라우터의 하드웨어 성능을 높여야해서 많은 비용이 들어감

## BGP
- 서로 다른 as를 연결하기 위한 path vector 방식의 bgp
- as를 나누게 되면 라우터 집단을 구분했기 때문에 트래픽이 줄어듦
- 구분하지 않았다면 그 정보가 다른 단체의 모든 라우터로 전달되어 트래픽이 많아질 것임
- 각 as에서 외부 as와 연결되는 라우터를 ASBR이라고 부름




## ICMP
- 네트워크에서 해당 목적지까지 데이터가 도달할 수 있는지, 그럴 수 없다면 그 원인이 무엇인지 알아내기 위한 프로토콜
- ICMP 데이터가 전달될 때 ICMP헤더에 IP헤더와 이더넷 헤더가 붙어서 전송됨
- 

## ARP
- IP주소로 MAC 주소를 알아내는 프로토콜
- 목적지 ip주소가 arp 캐시에 저장되어있는지 확인한 후 mac주소를 알아내어 효율적으로 작동

## public ip와 private ip
- 부족한 주소를 절약하기 위해서 ip 대역의 일정 부분은 private ip로 사용하기로 함
- private ip는 로컬 네트워크(lan)에서만 사용하기로 약속함
- 다른 lan끼리는 private ip가 똑같을 수 있음
- 꼭 필요한 곳에만 public ip를 부여해 ip 절약
- private ip는 클래스 a, b, c로 범위를 나누어 사용
- 로컬 영역에서는 private ip를 사용하므로 ip주소를 훨씬 많이 절약할 수 있지만 private ip는 외부 네트워크로 이동할 때 라우터에서 public ip로 바뀌어서 나가야 함
- 그렇지 않으면 ip 주소가 중복되어 통신에 문제가 생길 수 있음
- 


## NAT/ PAT
- PAT: 트랜스포트 계층의 포트까지 사용해 매핑 테이블을 작성하는 방식
	- PAT를 이용하면 하나의 public ip주소에 같은 네트워크에 존재하는 여러개의 private ip주소를 할당할 수 있음
	- ip주소가 같더라도 포트로 구분할 수 있음
	- 네트워크 장비의 포트(인터페이스)와 트랜스포트 계층의 포트는 다름
	- static PAT: 양방향 통신, 1:N 연결 방식
	- dynamic PAT: 포트를 자동으로 할당해줌, 단방향 통신: 1:N 연결 방식
	- 트랜스포트 계층에서 포트는 애플리케이션을 구분하는 숫자
- NAT: 네트워크 주소 변환, 프라이빗 주소를 퍼플릭 주소로 변환
	- static NAT: 관리자가 라우터에 직접 private ip주소에 public ip 주소를 매핑하는 방식, 양방향 통신, 1:1 연결 방식 -> 주소를 아낄 수는 없음. 보안의 목적
	- dynamic NAT: 관리자가 여러 개의 public ip를 준비해두고 요청한 호스트에게 여분의 public ip를 빌려주는 방식의 NAT, 양방향 통신, N:N 연결 방식 -> 여분 public ip가 없으면 통신할 수 없음
	
게임 회사는 NAT를 꺼리는가? 
	 -> Peer to peer 방식: 로딩이 가장 빠른 사람이 서버가 되어 반응 속도가 빠름
	 NAT traversal 문제 발생 가능성
	  ->  릴레이 서버를 만들어 해결 그러나 반응속도의 문제
	    홀 펀칭 방식으로 해결 랑데뷰 서버 이용

## 트랜스포트 계층
- 호스트로 도착한 데이터를 목적지 애플리케이션으로 정확히 전달하는 역할
- 데이터 링크 계층에서는 기기를 구분하는 용도로 mac 주소를 사용
- 네트워크 계층에서는 ip주소를 사용
- 트랜스포트 계층은 호스트 내에서 애플리케이션을 구분하는 용도로 포트를 사용
- 트랜스포트 계층에서 말하는 포트는 랜카드나 라우터에 있는 포트와는 다른 논리적인 개념
- 포트는 프로세스의 주소
- TCP와 UDP를 이용해 신뢰성있는 전송을 보장하거나 빠른 속도를 보장하는 전송방식을 선택할 수 있음

## TCP
- 트랜스포트 계층
- 정책적으로 데이터의 신뢰성을 보장하는 프로토콜
- 데이터를 분할해서 전송
- 커넥션 확립, 데이터 전송, 커넥션 끊기로 신뢰성 있는 데이터 전송
- 데이터가 분실되거나 손상되면 재전송을 보장, 순서가 바뀐 데이터 재조립
- 3way handshake
	- 상대방과 통신을 시작하는 단계로 데이터를 3번 송수신하면서 통신에 필요한 약속을 함
	- 사람1이 사람2에게 SYN패킷을 보냄
	- 사람 2는 ACK 패킷 즉, 확인 응답 패킷을 보내 통신을 수락하고 그와 함께 사람 2도 SYN 패킷을 보냄
	- 이때 최대 세그먼트 길이도 결정해서 보냄 -> TCP는 큰 데이터가 분실되는 경우 잃어버리는 데이터가 많이 발생하는 것을 막기 위해 데이터를 분할함
	- 이를 받은 사람1은 다시 응답 패킷 ACK를 보냄
	- 모든 과정 이후 커넥션이 확립되면 실질적인 데이터를 전송할 수 있게 됨
- 4way handshake(커넥션 끊기)
	- 사람 1이 FIN(파이널) 패킷을 보냄
	- 사람 2가 FIN 패킷에 대한 ACK 패킷과 함께 2도 FIN패킷을 보냄
	- 이에 대해 1이 ACK를 보내며 연결이 끊어짐

## UDP
- 신뢰성이 다소 떨어짐 그러나 자유로움
- TCP는 데이터가 분실되거나 손상되면 재전송을 보장하고 순서가 바뀐 데이터를 재조립하지만 UDP는 그렇지 않음
- 커넥션없이 바로 일방적으로 데이터 전송
- 신뢰성을 보장하고 싶다면 사용자가 직접 구현해야 함
- 신뢰성 보다는 속도가 중요한 곳에서 주로 사용

어떤 프로토콜을 사용할 지는 사용자의 역량에 따라 다름

## 애플리케이션 계층
- TCP/IP 5계층에서 애플리케이션 계층은 OSI 7계층의 세션, 프레젠테이션, 에플리케이션층을 통틀어 표현함
- 사용자는 애플리케이션 계층의 프로토콜을 이용해 애플리케이션을 만들 수 있음
- 네트워크가 계층화되어 있기에 하위 계층을 몰라도 구현 가능

## DHCP
- 중복되지 않는 ip설정의 필요성 -> 번거로움을 해결하기 위해 등장
- 컴퓨터가 적절한 ip로 자동으로 설정해주는 프로토콜
- 애플리케이션 계층
- 따로 DHCP 서버를 두거나 라우터에 포함되어 있음
- 호스트가 DHCP 서버에 IP를 요청하기 위해서 브로드캐스트 메세지를 보내는 것을 DHCP discovery라고 함
- DHCP 서버가 아닌 이들은 받은 메세지를 버리고 DHCP 서버는 이 메세지를 받아서 응답함
- 호스트의 요청에 ip를 제안하는 것을 DHCP offer
- 해당 ip를 요청하는 것을  DHCP request
- 최종적으로 해당 IP를 할당하겠다고 응답하는 것을 DHCP ACK

## DNS
- 웹 사이트마다 다른 ip주소를 외우기 어려움 -> 컴퓨터 ip마다 호스트 명을 부여하여 호스트를 구분
- 하지만 각 호스트는 다른 호스트의 호스트 명이 어떤지 알 수 없었음
- 호스트 파일에 정보를 저장해뒀음 

- 사용자가 호스트명을 입력하면 자동으로 해당 호스트의 ip가 저장되어있는 데이터베이스 서버로 연결되어 해당 ip 주소를 알게 해 줌
- 호스트가 다른 호스트명을 모두 가지고 있는 것이 아니라 분산된 데이터 베이스에 그 때마다 물어보는 것
- 도메인 명: 호스트들의 그룹을 나타내는 이름
	- 호스트 명이 하나의 호스트 ip를 나타내는 이름이라면 도메인은 호스트들의 그룹을 나타내는 이름
	- 도메인은 계층 구조
	- 도메인은 .으로 구분
	- 최상위 도메인은 .마지막 부분

## telnet과 ssh
- telnet 덕분에 네트워크 관리자들은 물리적으로 떨어져있는 라우터나 스위치 같은 장치에 직접 가지 않고도 네트워크 설정 가능
- 보안 취약성 문제로 telnet의 포트인 23번 포트를 막아둠, 로그인할 때 비밀번호가 암호화되지 않고 바로 전송되기 때문에 중간에서 해킹 가능
- ssh는 보안되어서 전송
	- 멀리 있는 컴퓨터에 접속하기 위해서 복호화에 사용하는 프라이빗 키, 암호화에 사용하는 퍼블릭 키 생성
	- 멀리 있는 컴퓨터에 퍼블릭 키를 알려줌
	- 이후에 멀리 있는 컴퓨터에 key를 이용해 로그인을 시도하면 멀리 있는 컴퓨터는 랜덤한 문자열을 퍼블릭 키로 암호화하고 내 컴퓨터로 전송
	- 내 컴퓨터에서 올바른 프라이빗 키를 가지고 있다면 암호화된 메세지를 복호화 할 수 있음
	- 이 메세지를 다시 멀리있는 컴퓨터에 전송하고 복호화된 문자열이 암호화 전 문자열과 같다면 인증이 완료

## FTP
- 파일을 전송할 때 쓰이는 프로토콜
- 연결을 위해 제어용, 전송용의 2개의 TCP 커넥션 생성
- 제어용으로 명령어 전달 전송용으로 파일 전달
- 인증 FTP와 익명 FTP


## 이메일에서 사용하는 프로토콜
- SMTP: 이메일을 전송할 때 사용, 항상 전원이 들어와 있는 메일 서버가 필요함, TCP 25번 포트 사용
- POP: 송신자 측에서 온 메일을 받을 때 중간에 메일 서버를 거침, 그때 이용, TCP 110번 포트 사용
- IMAP: 메일 서버에 도착한 이메일을 클라이언트가 읽더라도 삭제 x, 메일에 대한 정보 동기화 쉬움,TCP 143번 포트 사용

## HTTP
- 웹브라우저에서 쓰이는 프로토콜
- 웹브라우저는 HTTP를 이용해 통신, 모바일 애플리케이션도 사용하는 경우 있음
- 이를 사용해 호스트(도메인)과 통신
- 사용자가 HTTP를 이용해 서버에 요청을 보내면 서버와 TCP 커넥션을 확립하고 서버는 사용자가 요청한 데이터를 보내주고 TCP 연결을 끊음
- 매번 커넥션을 확립하고 끊는 것을 반복하다보니 번거로운 문제로 개선 중

- 요청 헤더
	- GET: 서버에 데이터를 요청하는 메서드. 해당 호스트에게 파일을 요청하는 것
	- POST: 서버에게 새로운 데이터를 저장해 달라고 요청하는 메서드
	- PUT: 기존의 데이터를 완전히 바꿔달라고 요청하는 메서드
	- PATCH: 기존 데이터 내용의 일부를 바꿔 달라고 요청하는 메서드
	- DELETE: 서버에게 데이터를 제거해달라고 요청하는 메서드
- 응답 헤더 
	- 100번대 
	- 200번대
		- 200: 클라이언트의 요청이 성공적으로 이뤄짐
		- 201: 클라이언트의 요청이 성공적이고 새로운 리소스가 만들어짐
	- 300번대
	- 400번대: 보통 클라이언트가 서버에게 잘못된 요청을 보낸 경우에 사용
		- 400: 클라이언트가 잘못된 문법으로 서버에게 보내서 서버가 요청을 이해할 수 없음
		- 403: 클라이언트가 해당 리소스에 접근할 권한이 없음
		- 404: 클라이언트가 존재하지 않는 리소스에 접근
	- 500번대: 서버에서 문제가 생겼을 때 사용
		- 500: 서버가 처리하는 과정에서 예상치 못한 상황일 때 응답
		- 502: 서버측 장비가 문제가 생겨서 제대로 연결할 수 없음

## L1,L2,L3,L4,L7 스위치와 로드밸런싱
- L1~L7은 OSI 7계층의 각 계층을 말함
- L1 스위치: 1계층 즉 물리 계층에는 스위치가 존재하지않지만 허브를 뜻함
- L2 스위치: 스위칭 허브
- L3 스위치: 라우터
- L4 스위치: L4 기술을 사용하는 라우터
- L3 스위치: L7 기술을 라우터
- 로드밸런싱: 로드 즉 부하를 밸런스 있게 나누는 것
	- L4에서 로드밸런싱은 NAT 사용
	- NAT는 사설망의 여러 장치가 하나의 공인 IP로 인터넷에 접속할 수 있도록, 내부 장치의 사설 출발지 IP 주소를 라우터의 공인 IP 주소로 바꿔주는 기능
	- 응답 패킷이 돌아올 때 다시 사설 IP로 변환

## 구글을 검색한다면?
- 스위치와 허브로 작은 LAN 생성 
- ISP에 연락하여 인터넷 설치, 라우터 설치
- 라우터는 NAT를 지원하기에 내부에서는 프라이빗 아이피 사용
- 이때 웹브라우저에 구글을 검색하면 웹브라우저가 HTTP의 GET매서드를 이용하여 구글 메인 화면 요청
- 구글의 도메인명은 DNS를 통해 IP 주소를 가져옴
- 디지털 데이터로 구성된 프레임은 LAN카드가 물리 신호로 변환
- 케이블을 타고 스위치로 이동, 라우터로 이동
- 디지털 신호로 다시 변환 후 ip헤더를 통해 목적지 파악
- 퍼블릭 주소로 변환하여 구글의 웹서버가 설치된 컴퓨터로 도착

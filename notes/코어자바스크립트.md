## 자바스크립트 메모리 영역
- stack memory
	- 변수
	- 기본형 데이터
	- 정적 할당
- heap memory
	- 참조형 데이터
	- 동적 할당

# 데이터 타입
## primitive type
- 기본형
- number
- string
- boolean
- null
- undefined
- symbol
## reference type
- 참조형
- array
- function
- regExp
- set/weakSet

## 실행 컨텍스트 Execution context
- 코드를 실행하는데에 필요한 배경이되는 조건/환경
- 동일한 조건/환경을 지니는 코드 뭉치를 실행할 때 필요한 조건/ 환경정보를 담은 객체
- 전역공간: 자바스크립트 코드가 실행되는 순간에 바로 전역 컨텍스트 생성, 전체 코드가 끝날 때 종료
- 함수
- eval
- module: import되는 순간에 모듈 내부에 있는 컨텍스트가 생성, 모듈 코드가 전부 끝났을 때에 컨텍스트 종료
- 전역공간, 함수, 모듈로 묶인 내부에서는 같은 환경안에 있다는 것이 성립

## 콜스택
- 제일 먼저 전역 컨텍스트가 열림
- 코드를 한 줄 한 줄 실행함
- 함수의 선언은 실행하는 명령이 아니므로 넘어가고 함수가 호출된 부분부터 실행

- 콜스택이란 현재 어떤 함수가 동작 중인지, 다음에 어떤 함수가 호출될 예정인지 등을 제어하는 자료 구조
- 최초에 전역 공간에 대한 컨텍스트가 콜스택에 쌓임 -> 실행
- 다음으로 제일 먼저 호출되는 함수의 컨텍스트가 콜스택의 쌓임 -> 다음으로 실행
- 그 다음 호출되는 함수의 컨텍스트가 콜스택에 쌓임 -> 그 다음으로 실행

- 실행 컨텍스트의 내부에는 3가지 환경 정보들이 쌓임
	- VariableEnvironment: 현재 환경과 관련된 식별자 정보들, 식별자 정보 수집, 내부 코드를 실행하는 동안에 변수의 값들에 변화가 생겨도 실시간 반영 x
	- LexicalEnvironment: 현재 환경과 관련된 식별자 정보들, 각 식별자의 데이터 추적, 내부 코드를 실행하는 동안에 변수의 값들에 변화가 생기면 실시간 반영
	- ThisBinding

- LexicalEnvironment
	- 어휘적 환경, 사전적 환경
	- 어떤 실행 컨텍스트 A에 대한 환경정보가 담겨 있는 사전
	- 실행 컨텍스트를 구성하는 환경 정보들을 모아 사전처럼 구성한 객체
	- environmentRecord: 현재 문맥의 식별자 정보, 호이스팅
		- 실행 컨텍스트가 처음 생성되는 순간에 제일 먼저하는 일
		- 호이스팅은 허구의 개념, 식별자들을 제일 위로 끌어 올리는 것 같은 효과
	- outerEnvironmentReference: 외부 환경에 대한 참조
		- 현재 문맥에 관련 있는 외부 식별자 정보
		- outerEnvironmentReference는 바로 밑에 있는 실행 컨텍스트 참조
		- scope chain: 외부로는 들어갈 수 있는데 자기보다 안쪽으로 들어갈 수는 없다 쉽게 말하면 밑에 있는 실행컨텍스트들은 참조 가능하지만 위는 불가능
			- 어떤 함수에서 특정 변수를 찾으라는 명령이 내려지면 일단 그 함수 내부에서 찾음
			- 만약에 없다면 outerEnvironmentReference를 통해 밑에 있는 컨텍스트에서 변수를 찾음
			- 즉 자기 내부에서부터 가장 가까운 스코프 순서대로 찾아 나감

## this
- thisBinding
	-  실행 컨텍스트가 활성화될 때 한다.
	- 즉, 함수가 호출될 때 결정된다.
	- 함수가 어떻게 호출되냐에 따라서 동적으로 바인딩 됨
- 전역공간에서: 전역 공간은 무조건 처음부터 호출이 되기 때문에 여기서 this는 정해져 있음 -> window/ global이라는 객체 host라고도 함
- 함수 호출 시: 함수를 호출했을 때도 전역 객체를 가리킴
- 함수를 메서드로 호출 시: 객체 안에 어떤 메서드가 있고 그 메서드로써 호출했을 때 this는 호출한 대상 객체가 바인딩 됨, 메서드 호출 주체가 this가 됨(메서드 명 앞)
- 함수를 callback으로 호출 시: 기본적으로는 함수 내부에서와 동일하게 전역 객체, 제어권을 가진 함수가 콜백의 this를 지정해둔 경우도 있음 -> 이 경우에도 개발자가 this를 바인딩해서 콜백을 넘기면 그에 따른다.
	- call 명령
	- apply 명령
	- bind 명령
- 함수를 생성자함수로써 호출 시(new 연산자를 썼을 때): 생성자 함수의 내용을 바탕으로 인스턴스 객체를 만드는 명령 -> 새로 만드는 인스턴스 객체 그 자체가 곧 this가 됨

## 콜백 함수
- 제어권 위임(실행 시점, 매개변수, this)
- 다른 함수의 인자로 콜백함수를 전달하면 다른 함수가 콜백함수의 제어권을 갖게 됨
- 특별한 요청(bind)이 없는 한 다른 함수에 미리 정해놓은 방식에 따라 콜백함수를 호출함
- 미리 정해놓은 방식이란 어떤 시점에 콜백을 호출할지, 인자에는 어떤 값들을 지정할지, this에 무엇을 바인딩할지 등을 말함
- 콜백은 함수! 즉 콜백으로 넘기는 것은 무조건 함수 -> 이때는 this에 전역 객체가 담김
	- arr.logValues(1,2); VS arr.forEach(obj.logValues);
	- 메소드로 호출 VS 콜백함수로 전달

## 클로저 closure
-  클로저란 함수가 실행될 때 매번 같이 발생 
- 내부함수와 LexicalEnvironment의 조합
- 어떠한 실행 컨텍스트 A 내부에서 함수 B를 선언 
- 그리고 그 때의 함수 B와 A의 lexicalEnvironment와의 조합에서 나타나는 특별한 현상
- B의 outerEnvironmentReference와 A의 environmentRecord의 조합
- 여기서 나타나는 특별한 현상이란 컨텍스트 A에서 선언한 변수를 내부함수 B에서 참조할 경우에 나타나는 특별한 현상
- 컨텍스트 A에서 선언한 변수 a를 참조하는 내부함수 B를 A의 외부로 전달할 경우, A가 종료된 이후에도 a가 사라지지 않는 현상
- -> 지역변수가 함수 종료 후에도 사라지지 않게 할 수 있음

## 프로토타입
- prototype: 프로토타입
- [ [prototype] ]: new 인스턴스의 프로토타입
- constructor: 생성자함수
- constructor  생성자 생성자함수의 프로토타입
	인스턴스 [ [prototype] ]
- 객체와 다르게 문자나 숫자와 같은 기본형  타입의 데이터들은 객체가 아니므로  [ [prototype] ]가 있을 수 없음
- 그런데도 개발자가 리터럴을 인스턴스인 것 처럼 사용하려고 하면, 즉 메서드를 쓰려고하면, 자바스크립트가 임시로 숫자나 문자 리터럴에 해당하는 생성자 함수의 인스턴스를 만듦
- 그 프로토타입에 있는 메서드를 적용해서 원하는 결과를 얻게 함
- 다시 인스턴스를 제거함
- 참조형 데이터들은 처음부터 인스턴스이기 때문에 위 과정을 거치지 않음
- null과 undefined를 제외한 모든 데이터 타입들은 이와 같은 생성자 함수가 존재
- 각 생성자 함수들의 프로토타입에는 각 데이터타입에만 해당하는 전용 메서드들이 정의되어있음
- .__ proto __ : 콘솔에 보이지는 않지만 접근하고자하면 접근이 가능함
- object.getPrototypeOf(instance): 공식적인 방법

## 클래스
- 공통적인 속성을 함께 묶은 덩어리
- 인스턴스는 해당 클래스의 속성을 지닌 구체적인 객체들
- 프로토타입 프로퍼티에 내부에 할당되지 않고 array 생성자 함수 객체에 직접 할당되어 있는 프로퍼티들을 스태틱 메서드, 스태틱 프로퍼티라고 함
	- 이들은 array 생성자 함수를 new 연산자 없이 함수로써 호출할 때에만 의미가 있는 값들
	- 
- function Bridge() {}
- Bridge.prototype = Person.prototype;
- Employee.prototype = new.Bridge();
- Employee.prototype.constructor = Employee;
